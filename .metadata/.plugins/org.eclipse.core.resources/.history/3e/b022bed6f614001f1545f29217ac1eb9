/*
 * ChargeControl.cpp
 *
 *  Created on: May 15, 2024
 *      Author: binhhv.23.1.99@gmail.com
 */

#include "ChargeControl.h"
#include "Monitor.h"
#include "Analog.h"
#include "DeviceProtection.h"

extern TIM_HandleTypeDef htim2;

namespace blib
{
    template<typename T>
    T constrainValue(T value, T minVal, T maxVal)
    {
        if (value < minVal)
        {
            return minVal;    // Nếu giá trị nhỏ hơn minVal, trả về minVal
        }
        else if (value > maxVal)
        {
            return maxVal;    // Nếu giá trị lớn hơn maxVal, trả về maxVal
        }
        else
        {
            return value;    // Nếu giá trị nằm trong khoảng, trả về giá trị ban đầu
        }
    }

    ChargeControl::ChargeControl()
    {
        mHtim = &htim2;
        buckDisable();
        mChargeState = false;
        HAL_TIM_Base_Start_IT(mHtim);    // khởi tạo ngắt cho TIM2
        HAL_TIM_PWM_Start(mHtim, TIM_CHANNEL_1);    //khởi tạo PWM cho TIM1
    }
    ChargeControl::~ChargeControl()
    {

    }
    void ChargeControl::run()
    {
        auto &analog = Analog::getInstance();
        if (/* ErrorCode != NO_ERROR || chargingPause = true */true)
        {
            buckDisable();
        }
        else
        {
            if (/* Recovery == true */true)
            {
//                recovery = false;
                buckDisable();

                Monitor::getInstance().impl_DisplayDetectPowerSource();
                analog.readAnalog();
                float pwm = predictPwm();
                Monitor::getInstance().impl_DisplayOff();
            }
            else
            {
                if (/*mpptMode == */false)
                {
                    static float currentCharging = analog.getIout();
                    float pwm = 0.0f;
                    float voltageBatteryMax = 30.0f;
                    float voltageBatteryMin = 11.0f;

                    if (analog.getIout() > currentCharging)
                    {
                        pwm--;
                    }
                    else if (analog.getVout() > voltageBatteryMax)
                    {
                        pwm--;
                    }
                    else if (analog.getVout() < voltageBatteryMin)
                    {
                        pwm++;
                    }
                    else
                    {

                    }

//                    pwmModulation(pwm);
                }
                else
                {
//                    static float currentCharging = analog.getIout();
//                    if (analog.getIout() > currentCharging)
//                    {
//
//                    }
                }
            }
        }
    }

    void ChargeControl::setBuckEnable(const bool val)
    {
        mBuckEnable = val;
    }
    bool ChargeControl::getBuckEnable() const
    {
        return mBuckEnable;
    }
    void ChargeControl::setMpptMode(const bool val)
    {
        mMpptMode = val;
    }
    bool ChargeControl::getMpptMode() const
    {
        return mMpptMode;
    }

    // Enable Mppt Buck converter
    void ChargeControl::buckEnable()
    {
        LOGI();
        setBuckEnable(true);
        HAL_GPIO_WritePin(BUCK_EN_GPIO_Port, BUCK_EN_Pin, GPIO_PIN_RESET);
        HAL_GPIO_WritePin(LED_RED_GPIO_Port, LED_RED_Pin, GPIO_PIN_RESET);
    }

    // Disable Mppt Buck converter
    void ChargeControl::buckDisable()
    {
        LOGI();
        setBuckEnable(false);
        HAL_GPIO_WritePin(BUCK_EN_GPIO_Port, BUCK_EN_Pin, GPIO_PIN_SET);
        HAL_GPIO_WritePin(LED_RED_GPIO_Port, LED_RED_Pin, GPIO_PIN_SET);
        mPwm = 0;
    }
    float ChargeControl::predictPwm()
    {
        auto &analog = Analog::getInstance();
        auto &devProtection = DeviceProtection::getInstance();

        float predictPwm = 0.0f, ppwmMargin = 0, pwmMax = 0, pwmMaxLimited = 1000;

        if (analog.getSolarVoltage() < 0.0f)
        {
            predictPwm = 0;
        }
        else
        {
            predictPwm = (ppwmMargin * pwmMax * analog.getVout())
                    / (100.0f * analog.getSolarVoltage());
        }

        predictPwm = constrainValue(predictPwm, 0.0f, pwmMaxLimited);

        return predictPwm;
    }
    void ChargeControl::generatePwm(uint32_t val)
    {
        __HAL_TIM_SET_COMPARE(mHtim, TIM_CHANNEL_1, val);
    }

    void ChargeControl::initPwm(uint32_t channel, uint32_t frequency, uint32_t dutyCycle)
    {
        TIM_OC_InitTypeDef sConfigOC;

        mHtim->Instance->PSC = (HAL_RCC_GetPCLK1Freq() / frequency) - 1;    // Tính toán giá trị prescaler dựa trên tần số mong muốn
        mHtim->Instance->ARR = dutyCycle;    // Giá trị duty cycle (0-ARR)
        mHtim->Instance->CCR1 = dutyCycle;    // Giá trị sử dụng cho kênh PWM

        sConfigOC.OCMode = TIM_OCMODE_PWM1;
        sConfigOC.Pulse = 8;
        sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
        sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
        if (HAL_TIM_PWM_ConfigChannel(mHtim, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
        {
            Error_Handler();
        }

        HAL_TIM_PWM_Start(htim, channel);
    }
}    // namespace blib

