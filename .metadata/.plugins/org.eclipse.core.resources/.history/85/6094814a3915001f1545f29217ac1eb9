/*
 * Analog.cpp
 *
 *  Created on: May 14, 2024
 *      Author: binhhv.23.1.99@gmail.com
 */

#include "Analog.h"
#include <cmath>
namespace blib
{
    Analog::Analog() : mHadc(&hadc1), mHdmaAdc(&hdma_adc1)
    {
        sampling();
    }

    Analog::~Analog()
    {
        HAL_ADC_Stop_DMA(mHadc);
    }

    // Lay mau ADC bang DMA
    void Analog::sampling()
    {
        HAL_ADC_Start_DMA(mHadc, mAdcValues, NUMBER_OF_CHANNELS);
    }

    float Analog::getSolarVoltage() const
    {
        return mVin;
    }
    float Analog::getSolarCurrent() const
    {
        return mIin;
    }
    float Analog::getVout() const
    {
        return mVout;
    }
    float Analog::getIout() const
    {
        return mIout;
    }
    float Analog::getTemp() const
    {
        return mTemp;
    }

    void Analog::readAnalog()
    {
        mVin = calSolarVoltage(mAdcValues[0]);
        mIin = calSolarCurrent(mAdcValues[1]);
        mVout = convertAdcChannel3(mAdcValues[2]);
        mIout = convertAdcChannel4(mAdcValues[3]);
        mTemp = convertAdcChannel5(mAdcValues[4]);

        // Power Source Detection
        if (mVin <= 3 && mVout < 3)
        {
            mInputSource = PowerSrc::USB_PORT;
        }
        else if (mVin > mVout)
        {
            mInputSource = PowerSrc::SOLAR;
        }
        else if (mVin < mVout)
        {
            mInputSource = PowerSrc::BATTERY;
        }
        else
        {

        }

        mPin = mVin * mIin;
        mPout = mPin * k_efficiency_rate;
        mOutputDeviation = (mVout / k_voltage_battery_max) * 100.0f;

        mBatteryPercent = ((mVout - k_voltage_battery_min)
                / (k_voltage_battery_max - k_voltage_battery_min)) * 100;
    }

    float Analog::calSolarVoltage(uint32_t adcValue)    // Convert adcValue -> Vin
    {
        return k_voltage_divider_input * ((float) adcValue / 4095) * 3.3;
    }

    float Analog::calSolarCurrent(uint32_t adcValue)    // Convert adcValue -> Iin
    {
        float voltage = k_current_divider_input * ((float) adcValue / 4095) * 3.3;
        float current = (voltage - (5 * 0.5)) / ACS_SENSITIVITY;    // Vic = 5V

        return current;
    }
    float Analog::convertAdcChannel3(uint32_t adcValue)    // Convert adcValue -> Vout
    {
        return k_voltage_divider_output * ((float) adcValue / 4095) * 3.3;
    }
    float Analog::convertAdcChannel4(uint32_t adcValue)    // Convert adcValue -> Iout
    {
        float voltage = k_current_divider_output * ((float) adcValue / 4095) * 3.3;
        float current = (voltage - (5 * 0.5)) / ACS_SENSITIVITY;    // Vic = 5V

        return current;
    }
    float Analog::convertAdcChannel5(uint32_t adcValue)    // Convert adcValue -> Temperature NTC 10k
    {
        const double A = 0.003354016f;
        const double B = 0.0002569850f;
        const double C = 0.000002620131f;

        float voltage = ((float) adcValue / 4095) * 3.3;
        float resistance = (3.3f * 10000.0f / voltage) - 10000.0f;

        float logResistance = log(resistance);
        float reciprocalTemperature = A + (B * logResistance)
                + (C * logResistance * logResistance * logResistance);

        float temperature = 1.0f / reciprocalTemperature;
        return temperature;
    }
}
// namespace blib

